PVI
===

.. note::

    This module is currently a proposal only, so all details are subject to
    change at any point. The documentation is written in the present tense, but
    no code is written yet.

PVI (PV Interface) is a framework for specifying the interface to an EPICS
driver in a single `YAML`_ file. The initial target is asyn port driver based
drivers, but it could be extended to streamDevice and other driver at a later
date.

It allows the asyn parameter interface to be specified in a single place,
and removes boilerplate code in the driver CPP, template files, documentation,
and low level opis:

.. digraph:: pvi_flowchart

    bgcolor=transparent
    rankdir=LR
    node [fontname=Arial fontsize=10 shape=box style=filled fillcolor="#8BC4E9"]
    edge [fontname=Arial fontsize=10 arrowhead=vee]

    {   rank=same;
        "pilatus.yaml"
        "pilatus_logic.template"
        "pilatus.cpp"
        "pilatus.h"
    }

    PVI [shape=doublecircle]
    "pilatus.yaml" -> PVI
    PVI -> "pilatus_parameters.cpp"
    PVI -> "pilatus_parameters.h"
    PVI -> "pilatus.template"
    PVI -> "pilatus_parameters.opi"
    PVI -> "pilatus_parameters.adl"
    PVI -> "pilatus_parameters.edl"
    PVI -> "pilatus_docs.html"
    "pilatus_logic.template" -> "pilatus.template" [label="include"]
    "pilatus_parameters.cpp" -> "libPilatus.so"
    "pilatus_parameters.h" -> "libPilatus.so"
    "pilatus.cpp" -> "libPilatus.so"
    "pilatus.h" -> "libPilatus.so"

What problems is it trying to solve
-----------------------------------

.. list-table:: Aims of PVI
    :widths: 20, 80
    :header-rows: 1

    * - Aim
      - Description
    * - Reduce boilerplate
      - At the moment you can write a simple asyn port driver in code, but
        there is a lot of boilerplate to connect it to the outside world.
        The createParam section, the database template records, and the
        lowest level screens are all quite repetitive and each layer looks
        like it could be autogenerated without much extra information
    * - Reduce copy paste errors
      - At the moment it is easy to create screens and database templates
        via copy and paste, but not changing a record name or parameter leads
        to hard to track down errors
    * - Support site specific styles for screens
      - Each site has their own style for screens, and many sites have their
        own site specific display manager. Rather than start with one display
        manager and convert, PVI takes a cut down Widget description (just a
        type, pv, and some formatting), and lets the site specific template
        generate the screen according to local styles


How it works
------------

The YAML file contains information about each asyn parameter that will be
exposed by the driver, it's name, type, description, initial value, which record
type it uses, whether it is writeable or read only, which widget should be used,
etc. PVI reads these and creates intermediate Record, Widget and AsynParam
objects which are passed to a site specific Producer. This is responsible
for taking the intermediate objects and writing a parameter CPP file, database
template, and site specific screens to disk.

YAML file
~~~~~~~~~

The YAML file is broken into 5 sections:

.. list-table:: YAML sections
    :widths: 20, 80
    :header-rows: 1

    * - Section
      - Description
    * - Producer type and arguments
      - This allows a site specific Producer to be selected (overridden with a
        .local file) and extra arguments like site specific local top level
        screens included
    * - Takes
      - These are the arguments that will be used in the resulting template,
        with descriptions and default values
    * - Defines
      - These are internally used variables that can be used in the components
    * - Components
      - Python functions with their arguments that produce the intermediate
        Record, Widget and AsynParam objects

The Defines are processed, then the Components produce their intermediate
Records, Widgets, etc, then the Producer consumes these with the Takes
arguments to create the Products:

.. digraph:: pvi_products

    bgcolor=transparent
    node [fontname=Arial fontsize=10 shape=box style=filled fillcolor="#8BC4E9"]
    edge [fontname=Arial fontsize=10 arrowhead=vee]

    Intermediate [label="[Record(),\n Widget(),\n AsynParam(), \nTemplateInclude()]"]
    Products [label="Template\nScreens\nDriver Params\nDocumentation"]

    {rank=same; Components -> Intermediate -> Producer -> Products}
    Defines -> Components
    Takes -> Producer

Here's a cut down YAML file that might describe a parameter in a detector:

.. code-block:: YAML

    type: pvi.producers.DLSAsynProducer
    boy_embed: pilatus_embed.opi
    pv_prefix: $(P)$(R)
    port: $(PORT)

    # Define the arguments that the template takes
    takes:
      - type: builtin.takes.string
        name: P
        description: Record prefix part 1

      - type: builtin.takes.string
        name: R
        description: Record prefix part 2

      - type: builtin.takes.string
        name: PORT
        description: Asyn port name

    components:
      # Include the definitions from ADBase.yaml for screen widgets
      - type: ADCore.includes.ADBase
        P: $(P)
        R: $(R)
        PORT: $(PORT)

      # Make a group box/section widget to hold some parameters
      - type: builtin.widgets.group
        name: AncillaryInformation

      # Make a single parameter with a demand and readback records
      - type: asyn.parameters.float64
        name: ThresholdEnergy
        description: |
            Threshold energy in keV.

            camserver uses this value to set the discriminators in each pixel.
            It is typically set to the incident x-ray energy ($(P)$(R)Energy),
            but sometimes other values may be preferable.
        prec: 3
        egu: keV
        initial_value: 10
        autosave_fields: VAL
        writeable: True
        widget: TextInput
        group: AncillaryInformation

      # Include a bit of logic from the db template
      - type: builtin.db.include
        filename: pilatus_logic.template










What changes would be required to add this to an existing areaDetector module?
------------------------------------------------------------------------------





Questions
---------

- Where should products go, are they built?






.. _YAML:
    https://en.wikipedia.org/wiki/YAML


