PVI
===

.. note::

    This module is currently a proposal only, so all details are subject to
    change at any point. The documentation is written in the present tense, but
    no code is written yet.

PVI (PV Interface) is a framework for specifying the interface to an EPICS
driver in a single `YAML`_ file. The initial target is asyn port driver based
drivers, but it could be extended to streamDevice and other driver at a later
date.

It allows the asyn parameter interface to be specified in a single place,
and removes boilerplate code in the driver CPP, template files, documentation,
and low level opis:

.. digraph:: pvi_flowchart

    bgcolor=transparent
    rankdir=LR
    node [fontname=Arial fontsize=10 shape=box style=filled fillcolor="#8BC4E9"]
    edge [fontname=Arial fontsize=10 arrowhead=vee]

    {   rank=same;
        "pilatus.yaml"
        "pilatus_logic.template"
        "pilatus.cpp"
        "pilatus.h"
    }

    PVI [shape=doublecircle]
    "pilatus.yaml" -> PVI
    PVI -> "pilatus_parameters.cpp"
    PVI -> "pilatus_parameters.h"
    PVI -> "pilatus.template"
    PVI -> "pilatus_parameters.opi"
    PVI -> "pilatus_parameters.adl"
    PVI -> "pilatus_parameters.edl"
    PVI -> "pilatus_docs.html"
    "pilatus_logic.template" -> "pilatus.template" [label="include"]
    "pilatus_parameters.cpp" -> "libPilatus.so"
    "pilatus_parameters.h" -> "libPilatus.so"
    "pilatus.cpp" -> "libPilatus.so"
    "pilatus.h" -> "libPilatus.so"

What problems is it trying to solve
-----------------------------------

.. list-table:: Aims of PVI

    * - Reduce boilerplate
      - At the moment you can write a simple asyn port driver in code, but
        there is a lot of boilerplate to connect it to the outside world.
        The createParam section, the database template records, and the
        lowest level screens are all quite repetitive and each layer looks
        like it could be autogenerated without much extra information
    * - Reduce copy paste errors
      - At the moment it is too easy to create screens and database templates
        via copy and paste, but not changing a record name or parameter leads
        to hard to track down errors
    * - Support site specific styles for screens
      - Each site has their own style for screens, and many sites have their
        own site specific display manager. Rather than start with one display
        manager and convert, PVI takes a cut down Widget description (just a
        type, pv, and some formatting), and lets the site specific template
        generate the screen according to local styles


How it works
------------

The YAML file contains information about each asyn parameter that will be
exposed by the driver, it's name, type, description, initial value, which record
type it uses, whether it is writeable or read only, which widget should be used,
etc. PVI reads these and creates intermediate Record, Widget and AsynParam
objects which are passed to a site specific Producer. This is responsible
for taking the intermediate objects and writing a parameter CPP file, database
template, and site specific screens to disk.

YAML file
~~~~~~~~~

The YAML file is broken into 5 sections:

.. list-table:: YAML sections

    * - Producer type and arguments
      - This allows a site specific Producer to be selected (overridden with a
        .local file) and extra arguments like site specific local top level
        screens included
    * - Takes
      - These are the arguments that will be used in the resulting template,
        with descriptions and default values
    * - Defines
      - These are internally used variables that can be used in the components
    * - Components
      - Python functions with their arguments that produce the intermediate
        Record, Widget and AsynParam objects

.. code-block:: YAML

    type: pvi.producers.DLSProducer
    boy_embed: pilatus_embed.opi

    takes:









Questions
---------

- Where should products go, are they built?






.. _YAML:
    https://en.wikipedia.org/wiki/YAML


